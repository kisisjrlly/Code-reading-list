- 论文：[XFT: Practical Fault Tolerance Beyond Crashes](https://www.usenix.org/conference/osdi16/technical-sessions/presentation/liu)
- Source Project：https://github.com/JamesHeppenstall/cos518_project
- 相关博客：XFT: Reimplementing XPaxos in Go
## 代码框架

```

-----------------初始化过程-------------------------------------

func Make(replicas []*network.ClientEnd, id int, privateKey *rsa.PrivateKey,
	publicKeys map[int]*rsa.PublicKey) *XPaxos {
	
	// Make时生成一个同步组，三次Make 会选择一个主，一个从，一个备份节点。。。例子中1号节点为主，2号为从，3号为备份
	xp.generateSynchronousGroup(int64(xp.view))
}

func (cfg *config) start1(i int) {
    // 对于第i个服务端，Make一下
    xp := Make(ends, i, cfg.privateKeys[i], cfg.publicKeys)
}

func makeConfig(t *testing.T, n int, unreliable bool) *config {

        // start 三次，i=0为客户端，然后三个服务端
    	for i := 1; i < cfg.n; i++ { // Create a full set of XPaxos servers
		cfg.start1(i)
	}
}

--------------------- 初始化过程结束------------------------------------

------------------ 数据同步过程-------------------------------------


func (xp *XPaxos) verify(server int, msgDigest [32]byte, signature []byte) bool { // Crypto signature verification
    // xp服务器验证第server个服务器的回应消息的真假，用公钥验证签名，如果成功，证明是server发过来的，并且主要验证消息没有被篡改
    // 如果消息没有被篡改的话，其实通过一个循环也可以验证这个消息是谁发过来的，但如果本来是别A//发的消息，但是被篡改了，xp验证为B发过来的，就错了，因此，需要证书中心。。。
	err := rsa.VerifyPKCS1v15(xp.publicKeys[server], crypto.SHA256, msgDigest[:], signature)
	if err != nil {
		return false
	}
	return true
}

func (xp *XPaxos) sendPrepare(server int, prepareEntry PrepareLogEntry, reply *Reply) bool {
    // 如果
	if xp.byzantine == true {
		for i := len(prepareEntry.Msg0.Signature) - 1; i > 0; i-- {
			j := rand.Intn(i + 1)
			prepareEntry.Msg0.Signature[i], prepareEntry.Msg0.Signature[j] = prepareEntry.Msg0.Signature[j], prepareEntry.Msg0.Signature[i]
		}
	}

	dPrintf("Prepare: from XPaxos server (%d) to XPaxos server (%d)\n", xp.id, server)
	return xp.replicas[server].Call("XPaxos.Prepare", prepareEntry, reply, xp.id)
}

func (xp *XPaxos) issuePrepare(server int, prepareEntry PrepareLogEntry, replyCh chan bool) {
    if ok := xp.sendPrepare(server, prepareEntry, reply); ok {
        xp.mu.Lock()
        //这是判断一下view编号？？？
		if xp.view != prepareEntry.Msg0.View {
			xp.mu.Unlock()
			return
	}
	
	//验证签名
	verification := xp.verify(server, reply.MsgDigest, reply.Signature)
}


func (xp *XPaxos) sendPing(server int, view int, reply *Reply) bool {
	dPrintf("Ping: from XPaxos server (%d) to XPaxos server (%d)\n", xp.id, server)
	return xp.replicas[server].Call("XPaxos.Ping", view, reply, xp.id)
}

func (xp *XPaxos) issuePing(server int, view int) {
	reply := &Reply{}
    
    // 如果ping不成功，那么就要发送suspect消息了，后面就要开始视图变更了，所以要求同步组内必须时刻能ping通
	if ok := xp.sendPing(server, view, reply); ok {
		return
	} else {
		go xp.issueSuspect(view)
	}
}

func (xp *XPaxos) Ping(view int, reply *Reply) {
	return
}

func (xp *XPaxos) Replicate(request ClientRequest, reply *Reply) {
    
    if xp.id == xp.getLeader() { // If XPaxos server is the leader
        for server, _ := range xp.synchronousGroup {
            //leader向同步组的其他所有的server发送prepare消息。。。
			if server != xp.id {
				go xp.issuePrepare(server, prepareEntry, replyCh)
			}
		}
    }else {
        // 如果不是leader，那么就去ping leader
		go xp.issuePing(xp.getLeader(), xp.view)
	}
}


// 
func (client *Client) sendReplicate(server int, request ClientRequest, reply *Reply) bool {
	dPrintf("Replicate: from client server (%d) to XPaxos server (%d)\n", CLIENT, server)
	return client.replicas[server].Call("XPaxos.Replicate", request, reply, CLIENT)
}


// 每个server都会执行这个命令，如果不能执行，就尝试5次，
func (client *Client) issueReplicate(server int, request ClientRequest, replyCh chan bool, retry int) {
	reply := &Reply{}
    // 返回成功的才执行
	if ok := client.sendReplicate(server, request, reply); ok {
		if reply.Success == true { // Only the leader should reply to client server
			replyCh <- reply.Success
		}
	} else {
		if retry < RETRY {
			retry++
			go client.issueReplicate(server, request, replyCh, retry)
		}
	}
}

cfg.client.Propose(nil)
func (client *Client) Propose(op interface{}) { // For simplicity, we assume the client's proposal is correct

        // 除了client以外，clinet像所有的服务器发送这个命令
    	for server, _ := range client.replicas {
		//fmt.Println("----", server)
		if server != CLIENT {
			go client.issueReplicate(server, request, replyCh, 0)
		}
	}

}



----------------- 数据同步过程结束-----------------------------------


```

## 摘要
尽管经过多年的深入研究，拜占庭容错(BFT)系统尚未在实践中得到应用。这是由于与崩溃容错(CFT)相比，BFT在资源、协议复杂性和性能方面的额外成本。BFT的这种开销来自于这样一种假设:一个强大的对手不仅能够完全控制拜占庭式的故障机器，同时还能够控制整个网络的消息交付计划，从而有效地诱导通信异步，并随意划分其他正确的机器。==然而，对许多从业者来说，这种强烈的攻击似乎无关紧要。==

本文介绍了一种构建可靠、安全的分布式系统的新方法——交叉容错(XFT)，并将其应用于经典的状态机复制(SMR)问题。简而言之，XFT SMR协议提供了广泛使用的异步CFT SMR协议(如Paxos和Raft)的可靠性保证，但也能容忍拜占庭式的故障，并结合网络的异步性，==只要大多数副本是正确的并同步通信==。这允许以CFT为代价开发XFT系统(在实践中已经付出了代价)，但严格来说，XFT的弹性比CFT |更强，有时甚至比BFT本身更强。

作为XFT的一个展示，我们介绍了XPaxos，这是第一个XFT SMR协议，并将其部署在地理复制设置中。虽然XPaxos提供了比CFT SMR更强的弹性，而且不需要额外的资源，但是它的性能与最先进的CFT协议相匹配。

## 引言
容忍任何类型的服务中断，无论是由简单的硬件故障还是大型灾难造成的，都是现代分布式系统生存的关键。云级别的应用程序必须具有内在的弹性，因为任何停机都会直接影响到它们背后的业务。现代生产系统(如[13日8])增加9 reliability1的采用了复杂的分布式协议容忍碰撞机故障以及网络故障,如网络分区或异步,这反映了否则正确的机器无法相互之间及时沟通。这些系统的核心通常是基于一致同意的状态机复制(SMR)原语的崩溃容错(CFT) [35,10]

这些系统无法处理non-crash(或拜占庭[29])的缺点,不仅包括恶意,敌对的行为,但也会出现错误的硬件、过期或损坏的数据存储系统,内存错误引起的物理效应,bug的软件、硬件故障由于更小的电路,和人类的错误导致国有资产管理和数据丢失。然而，在|实践中确实发生过这样的问题，这些故障中的每一个都有导致主要生产系统瘫痪并破坏其服务的公开记录[14,4]。

尽管自兰波特，肖斯塔克和
到目前为止，对于容忍非碰撞故障还没有实际的答案。特别是，异步拜占庭容错(BFT)，它承诺解决这个问题[9]，并没有达到这个期望，主要是因为它的额外成本相比CFT。也就是说,异步
(也就是说，最终同步“[18]”)BFT SMR必须使用至少3t + 1个副本来容忍t非崩溃故障[7]，而不是像Paxos[27]或Raft[33]那样，只使用2t + 1个副本来容忍CFT


与实践者[25]的观察结果一致，我们声称这个对手模型实际上对于部署系统中观察到的现象来说过于强大。例如，意外的非崩溃故障通常不会导致网络分区。在广域网和地理复制系统中，即使是恶意的非崩溃故障也很少会导致整个网络崩溃。众所周知，全能攻击者是这些错误背后的一个常见来源，这是设计阶段常用的一种强大的简化方法，但在实践中还没有看到类似的扩展。

在本文中，我们介绍了XFT(交叉容错的缩写)，这是一种构建高效的弹性分布式系统的新方法，既能容忍非崩溃(拜占庭式)故障，也能容忍网络故障(异步性)。简而言之，XFT允许构建弹性系统：
- 与异步CFT相比，不要使用额外的资源(副本)
- 保存异步CFT的所有可靠性保证(即在没有拜占庭式故障的情况下)
- 提供正确的服务(即即使拜占庭式的错误发生了，只要大多数复制品是正确的，并且能够彼此同步通信(也就是说，当少数复制品是拜占庭式的，由于网络故障或分区)

特别地，我们设想XFT适用于广域或地理复制系统[13]，也适用于任何其他部署，在这些部署中，对手无法轻松地同时协调足够的网络分区和复杂的机器操作。

作为XFT的一个展示，我们展示了XPaxos, XFT模型中的第一个状态机复制协议。XPaxos以高效和实用的方式容忍崩溃之外的故障，比最先进的CFT SMR协议(如Paxos或Raft)更能覆盖实际的故障场景。这没有资源开销，因为XPaxos使用2t+1个副本。为了验证XPaxos的性能，我们将其部署在跨全球Amazon EC2数据中心的地理复制设置中。特别是，我们在Apache ZooKeeper中集成了XPaxos，这是一个为云系统[19]提供的出色且广泛使用的协调服务。我们对EC2的评估显示，XPaxos在吞吐量和延迟方面的性能几乎与wan优化的Paxos变体相当，并且明显优于最佳可用的BFT协议。在我们的评估中，XPaxos甚至超过了内置在ZooKeeper[20]中的本地CFT SMR协议。

最后，也许令人惊讶的是，我们展示了XFT可以提供比最先进的BFT更严格的可靠性保证，例如，在假设机器故障和网络故障作为独立且相同分布的随机变量发生的情况下，对于特定的概率。为此，我们计算了资源最优CFT、BFT和XFT(如XPaxos)协议的一致性(系统安全性)和可用性(系统活性)的九位数。虽然XFT总是比CFT提供更严格的一致性和可用性保证，而且总是比BFT提供更严格的可用性保证，但是我们的可靠性分析表明，在某些情况下，XFT也比BFT提供更严格的一致性保证。

本文的其余部分组织如下。在第2节中，我们定义了系统模型，然后在第3节中定义了XFT模型。在第4节和第5节中，我们分别介绍了XPaxos及其在地理复制上下文中的评估。第6节提供了比较XFT与CFT和BFT的简化可靠性分析。我们概述了相关工作，并在第7节中结束。XPaxos的完整伪代码和正确性证明见附录B和C

## 2系统模型
机器。我们考虑一个消息传递分布式系统包含一组n = jΠjΠ的机器,也称为副本。此外，还有一组单独的客户机C。

客户机和副本可能会遇到拜占庭式的故障:我们区分崩溃故障(机器只是停止所有计算和通信)和非崩溃故障(机器可以任意操作，但不能破坏我们使用的密码原语(密码散列、mac、消息摘要和数字签名)。没有故障的机器叫做“正确的”。如果机器是正确的或出了故障，我们就说机器是良性的。我们进一步表示在某一时刻的复制故障数

网络。每对副本都通过可靠的点对点双向通信通道连接。此外，每个客户机可以与任何副本通信

## 3XFT模型

### 3.1XFT总结

然后将它们与正交的网络故障模型结合起来，要么是同步模型(在我们的意义上排除了网络故障)，要么是异步模型(包含任意数量的网络故障)。因此，以往的工作可以分为四类:同步CFT[16,35]、异步CFT[35,27,32]、同步BFT[29,17,6]、异步BFT[9,3]。

相比之下,XFT重新定义机器和网络之间的边界断层维度:XFT允许设计可靠的协议,容忍崩溃机器故障,不管网络故障的数量,同时,容忍non-crash机器故障时机器故障或分区的数量是在一个阈值。

为了形式化XFT，我们首先定义无政府状态，这是一种非常严重的系统状态，具有实际的非崩溃机器(副本)故障和大量不同类型的故障，如下所示：
拜占庭故障的机器数+非拜占庭故障机器数+网络分区的机器数>t

其中t为复制故障的阈值，t≤b n - 2 1c。换句话说，在无政府状态中，一些副本是非崩溃错误的，并且没有正确的和同步的大多数副本。

借助无政府状态的定义，我们可以根据任意分布式计算问题的安全特性定义其XFT协议[2]


协议P是一个XFT协议，如果P在所有执行中都满足安全性，而系统永远不会处于无政府状态。

### 3.2 XFT vsCFT/BFT

然而，这是一种误导，因为即使存在实际的非崩溃故障，XFT也无法与经过身份验证的同步BFT相比。具体地说，经过身份验证的同步BFT协议，比如开创性的拜占庭将军协议[29]，可能会违反与单个分区副本的一致性。例如，在n = 5个副本的情况下，执行3个副本是正确且同步的，其中一个副本是正确的，但是分区了，而另一个副本没有崩溃错误，XFT模型要求保持一致性，而拜占庭将军协议可能违反一致性。



XFT还提供了比异步BFT更严格的可用性保证。最后，XFT的一致性保证是异步BFT无法比拟的。一方面，在无政府状态之外，XFT与[n=3;n=2)，而异步BFT不是。另一方面，与XFT不同，异步BFT在无政府状态下是一致的，前提是非崩溃故障的数量小于n=3。我们将在第6节中进一步讨论这些问题，在第6节中，我们还量化了XFT和异步CFT/BFT之间的可靠性比较，假设存在独立故障的特殊情况

XFT也不强于经过身份验证的同步BFT，因为后者在完全没有网络故障的情况下可以容忍更多的机器故障。


### 3.3什么时候用xft
XFT背后的直觉源自这样一个假设:极其糟糕的“系统条件，例如无政府状态，非常罕见，并且在无政府状态中提供一致性保证可能不值得支付异步BFT溢价。

我们设想XFT用于这样的用例:在这种用例中，竞争对手无法轻松地同时协调足够的网络分区和非崩溃故障的机器操作。一些有趣的候选用例包括：

- 容忍意外的“非碰撞故障”。在不容易受到恶意行为和故意攻击的系统中，可以使用XFT来防止意外的非崩溃故障，可以假定这些故障在很大程度上独立于网络故障。在这种情况下，XFT可以用于加固CFT系统，而不需要大量的BFT开销。
- 广域网和地理复制系统。即使在系统易受恶意非崩溃故障影响的情况下，XFT也可能会显示出有用的信息，只要对手很难或很昂贵地协调攻击以危害拜占庭机器并同时分割足够多的副本。XFT特别有趣的是广域网和地理复制系统，它们通常具有冗余的通信路径，通常具有较小的网络级DoS攻击表面（例如，没有多播风暴和洪水）

- 块链。XFT感兴趣的一个地理复制系统的特例是区块链系统。在一个典型的区块链系统中，例如比特币[31]，参与者可能在经济上受到恶意行为的激励，但可能缺乏在（大量）正确参与者之间进行沟通的手段和能力。在这种情况下，XFT对于所谓的许可区块链尤其有趣，它基于状态机复制，而不是基于比特币风格的工作证明[39

## 4 XPaxos 协议

### xpaxos总览
XpaxOS是一种新的状态机复制（SMR）协议，专门在XFT模型中设计。xpaxos专门针对地理复制设置中的良好性能，其特点是网络是瓶颈，具有较高的链路延迟和相对较低的异类链路带宽。简言之，Xpaxos由三个主要组件组成。

- 一种常见的协议，它在多个副本之间复制并完全排序请求。粗略地说，这包括了最先进的CFT协议(例如Paxos的第2阶段)的副本之间的消息模式和通信复杂性，并通过使用数字签名加以加强。
- 一种新颖的视图更改协议，其中信息以分散、无领导的方式从一个视图（系统配置）传输到另一个视图。
- 故障检测(FD)机制，它可以帮助检测外部无政府状态下的非崩溃故障，这些故障会使系统处于无政府状态的不一致状态。FD机制的目标是最小化系统中长期存在的非崩溃故障(尤其是\数据丢失“故障”)的影响，并帮助在它们与足够多的崩溃故障和网络故障同时发生之前检测它们，从而将系统推入无政府状态。

xpaxos按一系列视图编排[9]。xpaxos的核心思想是，在给定视图中的常见情况操作期间，xpaxos只同步复制客户端请求到t+1副本，而t+1副本是同步组的成员（共n=2t+1个副本）。每个视图编号使用所有副本已知的映射唯一地确定同步组SGI。每个同步组由一个主要的和T的追随者组成，这两个追随者共同被称为活动副本。给定视图中剩余的T副本称为被动副本；或者，被动副本使用延迟复制方法从主动副本学习顺序[26]。除非同步组中存在机器或网络故障，否则不会更改视图。

在一般情况下(第4.2节)，客户机向主服务器发送数字签名的请求，然后跨t + 1活动副本复制主服务器。这些t + 1副本对所有复制请求的证明进行数字签名并将其本地日志记录到提交日志中。然后提交日志作为在视图更改中维护一致性的基础

xpaxos的视图更改（第4.3节）重新配置了整个同步组，而不仅仅是领导者。新同步组SGI+1的所有T+1活动副本都试图将状态从前面的视图传输到视图I+1。这种分散的视图更改方法与传统的CFT和BFT协议（如[27，9]）中的重新配置/视图更改形成鲜明对比，其中只有一个副本（主副本）领导视图更改并从以前的视图传输状态。这种差异对于在存在非崩溃故障（但不存在完全无政府状态）时跨Xpaxos视图保持一致性（即总顺序）至关重要。Xpaxos的这种新颖且分散的视图更改方案保证，即使存在非崩溃故障，但在无政府状态之外，新同步组sgi+1中的至少一个正确副本将能够从以前的视图中转移正确的状态，因为它能够联系到我更正了任何旧同步组的副本。

最后，xpaxos的fd方案的主要思想如下。在视图更改中，非崩溃故障副本（旧同步组的）可能无法将其最新状态传输到新同步组中的正确副本。此“数据丢失”故障很危险，因为当系统处于无政府状态时，它可能会违反一致性。但是，如果这些正确的副本可以与来自新同步组的正确副本同步通信，则可以使用来自某些正确副本（来自旧同步组）的提交日志的数字签名来检测此类故障。在某种意义上，使用xpaxos fd时，必须第一次出现严重的非崩溃机器故障，同时出现足够多的崩溃或分区机器（即无政府状态），以破坏一致性。

在下面，我们将解释XPaxos的核心部分(第4.2节)、视图更改(第4.3节)和故障检测(第4.4节)组件。我们将在4.5节中讨论XPaxos优化，并在4.6节中给出XPaxos正确性参数。附录a给出了XPaxos执行的一个例子。附录B和C给出了完整的伪代码和正确性证明

### 4.2 Common case

图2显示了xpaxos对于一般情况（t 2）和特殊情况t=1的常见情况消息模式。xpaxos专门针对t=1的情况进行了优化，在本例中，每个视图中只有两个活动副本，并且协议非常有效。特殊情况t=1在实践中也具有高度相关性（例如，扳手[13]）。在下面，我们首先解释一般情况下的xpaxos，然后重点讨论t=1的特殊情况。

### 4.3 视图变更

#### 4.3.2 视图变更初始化
如果视图i中的同步组(用sgi表示)没有取得进展，XPaxos将执行视图更改。只有sgi的活动副本才能启动视图更改。一个活跃的复制品sj 2 sgi发起一个视图改变如果(i) sj接收一条消息来自另一个活跃的复制,不符合协议(例如,一个无效的签名),(2)机厂的重新传输计时器到期,(3)sj不完整视图改变视图我及时,或(iv) sj接收到一个有效的怀疑消息的观点我在sgi从另一个副本。在视图更改启动后，sj停止参与当前视图并发送hsuspect;我;sjiσsj到所有其他副本。

#### 4.3.3执行视图变更


### 4.4故障检测
Xpaxos不能保证无政府状态的一致性。因此，如果非崩溃故障持续足够长的时间最终与足够的崩溃或网络故障同时出现，那么从长远来看，非崩溃故障可能会破坏xpaxos的一致性。为了解决长期存在的故障，我们为xpaxos提出了（另外一个可选的）故障检测（fd）机制。

粗略地说，FD保证了以下属性:如果机器p在无政府状态之外发生了非崩溃故障，从而导致无政府状态中的不一致，那么XPaxos FD将检测到p为错误(外部无政府状态)。换句话说，任何发生在无政府状态之外的潜在致命错误都将被XPaxos FD检测到

在这里，我们将描述fd在t=1的情况下的工作原理（详见第B.4节），重点是检测可能导致xpaxos在无政府状态下不一致的特定非崩溃故障一个数据丢失故障，非崩溃故障副本在视图更改前丢失了一些提交日志。直观地说，数据丢失故障是危险的，因为它们不能通过直接使用数字签名来防止。

我们的FD机制需要修改XPaxos视图更改如下:除了交换提交日志，副本还交换准备日志。注意，在t = 1的情况下，只有主服务器维护一个prepare日志(参见4.2节)。在新视图中，主准备器和跟踪器提交传输的提交和准备日志中包含的所有请求

通过上面的修改，为了破坏一致性，一个错误的主视图(前一个视图i)需要在提交日志和准备日志中都显示一个数据丢失错误。然而,这样一个数据丢失故障主要年代准备记录会发现,无政府状态外,因为(i)(正确)的追随者视图我会回复视图中的变化和(2)一个条目在主年代准备日志原因之前各自的追随者年代提交日志条目。通过简单地验证追随者提交日志中的签名，就可以检测到主节点的错误。相反，通过验证视图i的主视图i的提交日志中的签名，可以在无政府状态之外检测视图i追随者的提交日志中的数据丢失错误。

### 4.5 xpaxos的优化
尽管上面描述的常见情况和视图更改协议足以保证正确性，但我们对xpaxos应用了一些标准的性能优化。其中包括检查点和延迟复制[26]到被动副本（有助于缩短视图更改期间的状态传输）以及批处理和流水线（以提高吞吐量）。

### 4.6正确性参数
一致性(总订单)。XPaxos强制执行以下不变式，这是实现总顺序的关键

引理1。在无政府状态之外，如果良性客户机C在视图I中提交序列号为sn的请求请求req，而良性副本sk在视图I0>i中提交序列号为sn的请求req0，则req=req0。

良性客户机c只有在从sgi中的t + 1活动副本接收到匹配的响应之后，才提交序列号为sn的请求req。这意味着sgi中的每个良性副本都将req存储到序列号sn下的提交日志中。在下面的例子中，我们将重点讨论i0 = i + 1的特殊情况。这作为引理1的证明的基本步骤，通过在C节中给出的跨视图归纳来实现。

回想一下，在视图i0 = i+1中，来自sgi+1的所有(良性)副本都等待包含从其他副本传输的提交日志的nt = t+1视图更改消息，以及设置为2的计时器过期。然后，sgi+1中的副本在vc-final消息中交换此信息。注意，在anarchy之外，sgi+1中至少存在一个正确的同步副本，比如sj。因此，在序列号sn下在视图i + 1中提交req0的良性副本sk必须已经从sj接收了vc-final。反过来，sj等待t + 1视图更改消息(以及定时器2)，因此它从一些正确的同步副本sx 2 sgi接收到一个视图更改消息(这样的副本存在于sgi中，因为sgi中的大多数t副本都没有崩溃错误或分区)。由于sx将req存储在视图i中sn下的提交日志中，它将此信息以视图更改消息的形式转发给sj，而sj则在vc-final中将此信息转发给sk。因此req = req0

可利用性。如果同步组只包含正确和同步的副本，则可以保证xpaxos的可用性。通过最终的同步，我们可以假设，最终不会出现网络故障。此外，随着T+1副本的所有组合在活动副本的角色中旋转，Xpaxos保证最终，Xpaxos中的视图更改将与T+1正确和同步的活动副本一起完成。

## 5实验评估
我们选择了地理复制的广域网设置，因为我们相信这些设置更适合于能够容忍拜占庭式错误(包括XFT和BFT)的协议。事实上,在广域网设置(我)没有单点故障,如开关连接机器,(ii)没有相关的失败原因,例如,停电,一场风暴,或其他自然灾害,和(3)是很困难的对手充斥网络,相关网络和non-crash断层(最后一点是XFT相关)。

## 7相关工作和总结


我们通过XPaxos演示了XFT, XPaxos是一种新型的状态机复制协议，它的可靠性比最好的崩溃-故障解决(crt -faulttolerant, CFT)协议高得多，通信复杂性、性能和资源成本基本相同。也就是说，XPaxos使用2t + 1个副本，提供了CFT的所有可靠性保证，但也能够容忍非崩溃故障，只要大多数XPaxos副本是正确的，并且能够彼此同步通信。

由于XFT完全是在软件中实现的，因此它与现有的方法有根本的不同，后者依靠可靠的硬件将BFT的资源成本降低到仅2t+1副本[15、30、21、38]。

XPaxos也不同于PASC[14]，后者使得CFT协议能够容忍使用asc硬化的拜占庭式故障子集。asc硬化通过在每个副本中保存状态的两个副本来修改应用程序。在“断层多样性”假设下，即一个错误不会以同样的方式破坏国家的两个副本。与XPaxos不同，PASC不能容忍影响整个副本的拜占庭式错误(例如，两个状态副本)。

在本文中，我们没有探讨每种故障类别对不同容许故障数量的影响。简而言之，这种方法被称为混合故障模型，并在[37]中介绍，它将非碰撞故障的阈值（例如B）与故障阈值T（任何类别）区分开来，尽管后者应确保安全（通常为B T）。混合故障模型及其改进[11，34]似乎与我们的XFT方法正交。

具体来说，Visigoth容错（VFT）[34]是混合故障模型的最新改进。除了对非崩溃和崩溃故障具有不同的阈值外，VFT还通过定义VFT协议可以容忍的网络故障阈值来优化网络同步和异步之间的空间。然而，VFT不同于XFT，因为它为非突发故障和网络故障修复了单独的故障阈值。这种差异是基本的而不是符号性的，因为xft不能通过选择vft阈值的特定值来表示。例如，xpaxos可以容忍2t+1副本、T分区副本、T非崩溃错误和T崩溃错误，尽管不能同时发生。在VFT中指定这样的要求将产生至少3T+1个副本。此外，与xpaxos相比，vft协议具有更复杂的通信模式。也就是说，许多VFT概念仍然与XFT正交。在未来探索混合故障模型（包括其改进，如VFT）和XFT之间的相互作用将是很有意思的。

除了上述研究方向，本文还为今后的工作开辟了其他途径。例如，许多构建在SMR之上的重要分布式计算问题，如分布式存储和区块链，都值得通过XFT棱镜对它们进行新的研究。


